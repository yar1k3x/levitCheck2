{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\nconst process = require('process');\nconst {\n  Argument,\n  humanReadableArgName\n} = require('./argument.js');\nconst {\n  CommanderError\n} = require('./error.js');\nconst {\n  Help\n} = require('./help.js');\nconst {\n  Option,\n  splitOptionFlags,\n  DualOptions\n} = require('./option.js');\nconst {\n  suggestSimilar\n} = require('./suggestSimilar');\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this.registeredArguments = [];\n    this._args = this.registeredArguments; // deprecated old name\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default, env, cli etc\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._summary = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: str => process.stdout.write(str),\n      writeErr: str => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n    return this;\n  }\n\n  /**\n   * @returns {Command[]}\n   * @api private\n   */\n\n  _getCommandAndAncestors() {\n    const result = [];\n    for (let command = this; command; command = command.parent) {\n      result.push(command);\n    }\n    return result;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.trim().split(/ +/).forEach(detail => {\n      this.argument(detail);\n    });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this.registeredArguments.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this.registeredArguments.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  }\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = err => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = args => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this.registeredArguments.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Wrap parseArgs to catch 'commander.invalidArgument'.\n   *\n   * @param {Option | Argument} target\n   * @param {string} value\n   * @param {*} previous\n   * @param {string} invalidArgumentMessage\n   * @api private\n   */\n\n  _callParseArg(target, value, previous, invalidArgumentMessage) {\n    try {\n      return target.parseArg(value, previous);\n    } catch (err) {\n      if (err.code === 'commander.invalidArgument') {\n        const message = `${invalidArgumentMessage} ${err.message}`;\n        this.error(message, {\n          exitCode: err.exitCode,\n          code: err.code\n        });\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        val = this._callParseArg(option, val, oldValue, invalidValueMessage);\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n    this.on('option:' + oname, val => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, val => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required\n   * option-argument is indicated by `<>` and an optional option-argument by `[]`.\n   *\n   * See the README for more details, and see also addOption() and requiredOption().\n   *\n   * @example\n   * program\n   *     .option('-p, --pepper', 'add pepper')\n   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument\n   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default\n   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [parseArg] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, parseArg, defaultValue) {\n    return this._optionEx({}, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [parseArg] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, parseArg, defaultValue) {\n    return this._optionEx({\n      mandatory: true\n    }, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    // if (Object.keys(this._optionValues).length) {\n    //   throw new Error('call .storeOptionsAsProperties() before setting option values');\n    // }\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    return this.setOptionValueWithSource(key, value, undefined);\n  }\n\n  /**\n    * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli/implied\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n    * Get source of option value. See also .optsWithGlobals().\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSourceWithGlobals(key) {\n    // global overwrites local, like optsWithGlobals\n    let source;\n    this._getCommandAndAncestors().forEach(cmd => {\n      if (cmd.getOptionValueSource(key) !== undefined) {\n        source = cmd.getOptionValueSource(key);\n      }\n    });\n    return source;\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));\n      if (foundExt) return `${localBin}${foundExt}`;\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch (err) {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));\n        if (legacyName !== this._name) {\n          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n        proc = childProcess.spawn(process.argv[0], args, {\n          stdio: 'inherit'\n        });\n      } else {\n        proc = childProcess.spawn(executableFile, args, {\n          stdio: 'inherit'\n        });\n      }\n    } else {\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, {\n        stdio: 'inherit'\n      });\n    }\n    if (!proc.killed) {\n      // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach(signal => {\n        // @ts-ignore\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', err => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n        const executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n        throw new Error(executableMissing);\n        // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({\n      error: true\n    });\n    let promiseChain;\n    promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');\n    promiseChain = this._chainOrCall(promiseChain, () => {\n      if (subCommand._executableHandler) {\n        this._executeSubCommand(subCommand, operands.concat(unknown));\n      } else {\n        return subCommand._parseCommand(operands, unknown);\n      }\n    });\n    return promiseChain;\n  }\n\n  /**\n   * Invoke help directly if possible, or dispatch if necessary.\n   * e.g. help foo\n   *\n   * @api private\n   */\n\n  _dispatchHelpCommand(subcommandName) {\n    if (!subcommandName) {\n      this.help();\n    }\n    const subCommand = this._findCommand(subcommandName);\n    if (subCommand && !subCommand._executableHandler) {\n      subCommand.help();\n    }\n\n    // Fallback to parsing the help flag to invoke the help.\n    return this._dispatchSubcommand(subcommandName, [], [this._helpLongFlag || this._helpShortFlag]);\n  }\n\n  /**\n   * Check this.args against expected this.registeredArguments.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this.registeredArguments.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this.registeredArguments.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this.registeredArguments and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;\n        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);\n      }\n      return parsedValue;\n    };\n    this._checkNumberOfArguments();\n    const processedArgs = [];\n    this.registeredArguments.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    this._getCommandAndAncestors().reverse().filter(cmd => cmd._lifeCycleHooks[event] !== undefined).forEach(hookedCommand => {\n      hookedCommand._lifeCycleHooks[event].forEach(callback => {\n        hooks.push({\n          hookedCommand,\n          callback\n        });\n      });\n    });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n    hooks.forEach(hookDetail => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {Command} subCommand\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallSubCommandHook(promise, subCommand, event) {\n    let result = promise;\n    if (this._lifeCycleHooks[event] !== undefined) {\n      this._lifeCycleHooks[event].forEach(hook => {\n        result = this._chainOrCall(result, () => {\n          return hook(this, subCommand);\n        });\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    this._parseOptionsImplied();\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      return this._dispatchHelpCommand(operands[1]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({\n        error: true\n      });\n    }\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n      let promiseChain;\n      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');\n      promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));\n      if (this.parent) {\n        promiseChain = this._chainOrCall(promiseChain, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');\n      return promiseChain;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) {\n        // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({\n        error: true\n      });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach(cmd => {\n      cmd.options.forEach(anOption => {\n        if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together in this.\n   *\n   * @api private\n   */\n  _checkForConflictingLocalOptions() {\n    const definedNonDefaultOptions = this.options.filter(option => {\n      const optionKey = option.attributeName();\n      if (this.getOptionValue(optionKey) === undefined) {\n        return false;\n      }\n      return this.getOptionValueSource(optionKey) !== 'default';\n    });\n    const optionsWithConflicting = definedNonDefaultOptions.filter(option => option.conflictsWith.length > 0);\n    optionsWithConflicting.forEach(option => {\n      const conflictingAndDefined = definedNonDefaultOptions.find(defined => option.conflictsWith.includes(defined.attributeName()));\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n  _checkForConflictingOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach(cmd => {\n      cmd._checkForConflictingLocalOptions();\n    });\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else {\n            // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || option.optional && this._combineFlagAndOptionalValue) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n    return {\n      operands,\n      unknown\n    };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return this._getCommandAndAncestors().reduce((combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()), {});\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {Object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({\n        error: true\n      });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach(option => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) {\n            // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else {\n            // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply any implied option values, if option is undefined or default value.\n   *\n   * @api private\n   */\n  _parseOptionsImplied() {\n    const dualHelper = new DualOptions(this.options);\n    const hasCustomOptionValue = optionKey => {\n      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));\n    };\n    this.options.filter(option => option.implied !== undefined && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach(option => {\n      Object.keys(option.implied).filter(impliedKey => !hasCustomOptionValue(impliedKey)).forEach(impliedKey => {\n        this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');\n      });\n    });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, {\n      code: 'commander.missingArgument'\n    });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, {\n      code: 'commander.optionMissingArgument'\n    });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, {\n      code: 'commander.missingMandatoryOptionValue'\n    });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @api private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = option => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());\n      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());\n      if (negativeOption && (negativeOption.presetArg === undefined && optionValue === false || negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n    const getErrorMessage = option => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, {\n      code: 'commander.conflictingOption'\n    });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command).filter(option => option.long).map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, {\n      code: 'commander.unknownOption'\n    });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n    const expected = this.registeredArguments.length;\n    const s = expected === 1 ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, {\n      code: 'commander.excessArguments'\n    });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach(command => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, {\n      code: 'commander.unknownCommand'\n    });\n  }\n\n  /**\n   * Get or set the program version.\n   *\n   * This method auto-registers the \"-V, --version\" option which will print the version number.\n   *\n   * You can optionally supply the flags and description to override the defaults.\n   *\n   * @param {string} [str]\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string | undefined} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName(); // [sic] not defined in constructor, partly legacy, partly only needed at root\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n  summary(str) {\n    if (str === undefined) return this._summary;\n    this._summary = str;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n    aliases.forEach(alias => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n      const args = this.registeredArguments.map(arg => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(this.options.length || this._hasHelpOption ? '[options]' : [], this.commands.length ? '[command]' : [], this.registeredArguments.length ? args : []).join(' ');\n    }\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {string|null|Command}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = {\n      error: !!contextOptions.error\n    };\n    let write;\n    if (context.error) {\n      write = arg => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = arg => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n    this._getCommandAndAncestors().reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n    if (this._helpLongFlag) {\n      this.emit(this._helpLongFlag); // deprecated\n    }\n    this.emit('afterHelp', context);\n    this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, context => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({\n          error: context.error,\n          command: context.command\n        });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map(arg => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\nexports.Command = Command;","map":{"version":3,"names":["EventEmitter","require","childProcess","path","fs","process","Argument","humanReadableArgName","CommanderError","Help","Option","splitOptionFlags","DualOptions","suggestSimilar","Command","constructor","name","commands","options","parent","_allowUnknownOption","_allowExcessArguments","registeredArguments","_args","args","rawArgs","processedArgs","_scriptPath","_name","_optionValues","_optionValueSources","_storeOptionsAsProperties","_actionHandler","_executableHandler","_executableFile","_executableDir","_defaultCommandName","_exitCallback","_aliases","_combineFlagAndOptionalValue","_description","_summary","_argsDescription","undefined","_enablePositionalOptions","_passThroughOptions","_lifeCycleHooks","_showHelpAfterError","_showSuggestionAfterError","_outputConfiguration","writeOut","str","stdout","write","writeErr","stderr","getOutHelpWidth","isTTY","columns","getErrHelpWidth","outputError","_hidden","_hasHelpOption","_helpFlags","_helpDescription","_helpShortFlag","_helpLongFlag","_addImplicitHelpCommand","_helpCommandName","_helpCommandnameAndArgs","_helpCommandDescription","_helpConfiguration","copyInheritedSettings","sourceCommand","_getCommandAndAncestors","result","command","push","nameAndArgs","actionOptsOrExecDesc","execOpts","desc","opts","match","cmd","createCommand","description","isDefault","noHelp","hidden","executableFile","arguments","createHelp","Object","assign","configureHelp","configuration","configureOutput","showHelpAfterError","displayHelp","showSuggestionAfterError","displaySuggestion","addCommand","Error","createArgument","argument","fn","defaultValue","default","argParser","addArgument","names","trim","split","forEach","detail","previousArgument","slice","variadic","required","parseArg","addHelpCommand","enableOrNameAndArgs","_hasImplicitHelpCommand","length","_findCommand","hook","event","listener","allowedValues","includes","join","exitOverride","err","code","_exit","exitCode","message","exit","action","expectedArgsCount","actionArgs","apply","createOption","flags","_callParseArg","target","value","previous","invalidArgumentMessage","error","addOption","option","oname","attributeName","negate","positiveLongFlag","long","replace","_findOption","setOptionValueWithSource","handleOptionValue","val","invalidValueMessage","valueSource","presetArg","oldValue","getOptionValue","_concatValue","isBoolean","optional","on","envVar","_optionEx","config","makeOptionMandatory","mandatory","RegExp","regex","def","m","exec","requiredOption","combineFlagAndOptionalValue","combine","allowUnknownOption","allowUnknown","allowExcessArguments","allowExcess","enablePositionalOptions","positional","passThroughOptions","passThrough","storeOptionsAsProperties","storeAsProperties","key","setOptionValue","source","getOptionValueSource","getOptionValueSourceWithGlobals","_prepareUserArgs","argv","parseOptions","Array","isArray","versions","electron","from","userArgs","defaultApp","nameFromFilename","parse","_parseCommand","parseAsync","_executeSubCommand","subcommand","launchWithNode","sourceExt","findFile","baseDir","baseName","localBin","resolve","existsSync","extname","foundExt","find","ext","_checkForMissingMandatoryOptions","_checkForConflictingOptions","executableDir","resolvedScriptPath","realpathSync","dirname","localFile","legacyName","basename","proc","platform","unshift","incrementNodeInspectorPort","execArgv","concat","spawn","stdio","execPath","killed","signals","signal","kill","exitCallback","bind","executableDirMessage","executableMissing","wrappedError","nestedError","runningCommand","_dispatchSubcommand","commandName","operands","unknown","subCommand","help","promiseChain","_chainOrCallSubCommandHook","_chainOrCall","_dispatchHelpCommand","subcommandName","_checkNumberOfArguments","arg","i","missingArgument","_excessArguments","_processArguments","myParseArg","parsedValue","declaredArg","index","reduce","processed","v","promise","then","_chainOrCallHooks","hooks","reverse","filter","hookedCommand","callback","hookDetail","parsed","_parseOptionsEnv","_parseOptionsImplied","outputHelpIfRequested","checkForUnknownOptions","unknownOption","commandEvent","emit","listenerCount","unknownCommand","is","anOption","missingMandatoryOptionValue","_checkForConflictingLocalOptions","definedNonDefaultOptions","optionKey","optionsWithConflicting","conflictsWith","conflictingAndDefined","defined","_conflictingOption","dest","maybeOption","activeVariadicOption","shift","optionMissingArgument","test","indexOf","len","_versionOptionName","_version","optsWithGlobals","combinedOptions","errorOptions","outputHelp","env","dualHelper","hasCustomOptionValue","implied","valueFromOption","keys","impliedKey","conflictingOption","findBestOptionFromValue","optionValue","negativeOption","positiveOption","getErrorMessage","bestOption","flag","suggestion","startsWith","candidateFlags","moreFlags","visibleOptions","map","receivedArgs","expected","s","forSubcommand","unknownName","candidateNames","visibleCommands","alias","version","versionOption","argsDescription","summary","aliases","usage","_usage","filename","helpInformation","contextOptions","helper","helpWidth","formatHelp","_getHelpContext","context","deprecatedCallback","Buffer","isBuffer","helpOption","helpFlags","shortFlag","longFlag","addHelpText","position","text","helpEvent","helpStr","debugOption","debugHost","debugPort","parseInt","exports"],"sources":["/Users/a1/new app/frontend/node_modules/auth/node_modules/commander/lib/command.js"],"sourcesContent":["const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\nconst process = require('process');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, splitOptionFlags, DualOptions } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this.registeredArguments = [];\n    this._args = this.registeredArguments; // deprecated old name\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default, env, cli etc\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._summary = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * @returns {Command[]}\n   * @api private\n   */\n\n  _getCommandAndAncestors() {\n    const result = [];\n    for (let command = this; command; command = command.parent) {\n      result.push(command);\n    }\n    return result;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.trim().split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this.registeredArguments.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this.registeredArguments.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  }\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this.registeredArguments.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Wrap parseArgs to catch 'commander.invalidArgument'.\n   *\n   * @param {Option | Argument} target\n   * @param {string} value\n   * @param {*} previous\n   * @param {string} invalidArgumentMessage\n   * @api private\n   */\n\n  _callParseArg(target, value, previous, invalidArgumentMessage) {\n    try {\n      return target.parseArg(value, previous);\n    } catch (err) {\n      if (err.code === 'commander.invalidArgument') {\n        const message = `${invalidArgumentMessage} ${err.message}`;\n        this.error(message, { exitCode: err.exitCode, code: err.code });\n      }\n      throw err;\n    }\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        val = this._callParseArg(option, val, oldValue, invalidValueMessage);\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.\n   *\n   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required\n   * option-argument is indicated by `<>` and an optional option-argument by `[]`.\n   *\n   * See the README for more details, and see also addOption() and requiredOption().\n   *\n   * @example\n   * program\n   *     .option('-p, --pepper', 'add pepper')\n   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument\n   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default\n   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [parseArg] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, parseArg, defaultValue) {\n    return this._optionEx({}, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [parseArg] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, parseArg, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    // if (Object.keys(this._optionValues).length) {\n    //   throw new Error('call .storeOptionsAsProperties() before setting option values');\n    // }\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    return this.setOptionValueWithSource(key, value, undefined);\n  }\n\n  /**\n    * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli/implied\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n    * Get source of option value. See also .optsWithGlobals().\n    * Expected values are default | config | env | cli | implied\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSourceWithGlobals(key) {\n    // global overwrites local, like optsWithGlobals\n    let source;\n    this._getCommandAndAncestors().forEach((cmd) => {\n      if (cmd.getOptionValueSource(key) !== undefined) {\n        source = cmd.getOptionValueSource(key);\n      }\n    });\n    return source;\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));\n      if (foundExt) return `${localBin}${foundExt}`;\n\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch (err) {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));\n        if (legacyName !== this._name) {\n          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach((signal) => {\n        // @ts-ignore\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableDirMessage = executableDir\n          ? `searched for local subcommand relative to directory '${executableDir}'`\n          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n        const executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    let promiseChain;\n    promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');\n    promiseChain = this._chainOrCall(promiseChain, () => {\n      if (subCommand._executableHandler) {\n        this._executeSubCommand(subCommand, operands.concat(unknown));\n      } else {\n        return subCommand._parseCommand(operands, unknown);\n      }\n    });\n    return promiseChain;\n  }\n\n  /**\n   * Invoke help directly if possible, or dispatch if necessary.\n   * e.g. help foo\n   *\n   * @api private\n   */\n\n  _dispatchHelpCommand(subcommandName) {\n    if (!subcommandName) {\n      this.help();\n    }\n    const subCommand = this._findCommand(subcommandName);\n    if (subCommand && !subCommand._executableHandler) {\n      subCommand.help();\n    }\n\n    // Fallback to parsing the help flag to invoke the help.\n    return this._dispatchSubcommand(subcommandName, [], [\n      this._helpLongFlag || this._helpShortFlag\n    ]);\n  }\n\n  /**\n   * Check this.args against expected this.registeredArguments.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this.registeredArguments.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this.registeredArguments.length > 0 && this.registeredArguments[this.registeredArguments.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this.registeredArguments.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this.registeredArguments and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;\n        parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this.registeredArguments.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    this._getCommandAndAncestors()\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {Command} subCommand\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallSubCommandHook(promise, subCommand, event) {\n    let result = promise;\n    if (this._lifeCycleHooks[event] !== undefined) {\n      this._lifeCycleHooks[event].forEach((hook) => {\n        result = this._chainOrCall(result, () => {\n          return hook(this, subCommand);\n        });\n      });\n    }\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    this._parseOptionsImplied();\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      return this._dispatchHelpCommand(operands[1]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let promiseChain;\n      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');\n      promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));\n      if (this.parent) {\n        promiseChain = this._chainOrCall(promiseChain, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');\n      return promiseChain;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together in this.\n   *\n   * @api private\n   */\n  _checkForConflictingLocalOptions() {\n    const definedNonDefaultOptions = this.options.filter(\n      (option) => {\n        const optionKey = option.attributeName();\n        if (this.getOptionValue(optionKey) === undefined) {\n          return false;\n        }\n        return this.getOptionValueSource(optionKey) !== 'default';\n      }\n    );\n\n    const optionsWithConflicting = definedNonDefaultOptions.filter(\n      (option) => option.conflictsWith.length > 0\n    );\n\n    optionsWithConflicting.forEach((option) => {\n      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>\n        option.conflictsWith.includes(defined.attributeName())\n      );\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n  _checkForConflictingOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    this._getCommandAndAncestors().forEach((cmd) => {\n      cmd._checkForConflictingLocalOptions();\n    });\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return this._getCommandAndAncestors().reduce(\n      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),\n      {}\n    );\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {Object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply any implied option values, if option is undefined or default value.\n   *\n   * @api private\n   */\n  _parseOptionsImplied() {\n    const dualHelper = new DualOptions(this.options);\n    const hasCustomOptionValue = (optionKey) => {\n      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));\n    };\n    this.options\n      .filter(option => (option.implied !== undefined) &&\n        hasCustomOptionValue(option.attributeName()) &&\n        dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))\n      .forEach((option) => {\n        Object.keys(option.implied)\n          .filter(impliedKey => !hasCustomOptionValue(impliedKey))\n          .forEach(impliedKey => {\n            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');\n          });\n      });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, { code: 'commander.missingArgument' });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, { code: 'commander.optionMissingArgument' });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, { code: 'commander.missingMandatoryOptionValue' });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @api private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = (option) => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());\n      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());\n      if (negativeOption && (\n        (negativeOption.presetArg === undefined && optionValue === false) ||\n        (negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)\n      )) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n\n    const getErrorMessage = (option) => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, { code: 'commander.conflictingOption' });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownOption' });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this.registeredArguments.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, { code: 'commander.excessArguments' });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownCommand' });\n  }\n\n  /**\n   * Get or set the program version.\n   *\n   * This method auto-registers the \"-V, --version\" option which will print the version number.\n   *\n   * You can optionally supply the flags and description to override the defaults.\n   *\n   * @param {string} [str]\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string | undefined} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName(); // [sic] not defined in constructor, partly legacy, partly only needed at root\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n  summary(str) {\n    if (str === undefined) return this._summary;\n    this._summary = str;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this.registeredArguments.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this.registeredArguments.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {string|null|Command}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    this._getCommandAndAncestors().reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    if (this._helpLongFlag) {\n      this.emit(this._helpLongFlag); // deprecated\n    }\n    this.emit('afterHelp', context);\n    this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\nexports.Command = Command;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}