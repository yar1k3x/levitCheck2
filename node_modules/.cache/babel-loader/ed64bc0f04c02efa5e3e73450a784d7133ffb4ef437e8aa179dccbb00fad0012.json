{"ast":null,"code":"const {\n  InvalidArgumentError\n} = require('./error.js');\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n    this.implied = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {*} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {string | string[]} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   *\n   * @param {Object} impliedOptionValues\n   * @return {Option}\n   */\n  implies(impliedOptionValues) {\n    let newImplied = impliedOptionValues;\n    if (typeof impliedOptionValues === 'string') {\n      // string is not documented, but easy mistake and we can do what user probably intended.\n      newImplied = {\n        [impliedOptionValues]: true\n      };\n    }\n    this.implied = Object.assign(this.implied || {}, newImplied);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   *\n   * An environment variable is only used if when processed the current option value is\n   * undefined, or the source of the current value is 'default' or 'config' or 'env'.\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @api private\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.\n */\nclass DualOptions {\n  /**\n   * @param {Option[]} options\n   */\n  constructor(options) {\n    this.positiveOptions = new Map();\n    this.negativeOptions = new Map();\n    this.dualOptions = new Set();\n    options.forEach(option => {\n      if (option.negate) {\n        this.negativeOptions.set(option.attributeName(), option);\n      } else {\n        this.positiveOptions.set(option.attributeName(), option);\n      }\n    });\n    this.negativeOptions.forEach((value, key) => {\n      if (this.positiveOptions.has(key)) {\n        this.dualOptions.add(key);\n      }\n    });\n  }\n\n  /**\n   * Did the value come from the option, and not from possible matching dual option?\n   *\n   * @param {*} value\n   * @param {Option} option\n   * @returns {boolean}\n   */\n  valueFromOption(value, option) {\n    const optionKey = option.attributeName();\n    if (!this.dualOptions.has(optionKey)) return true;\n\n    // Use the value to deduce if (probably) came from the option.\n    const preset = this.negativeOptions.get(optionKey).presetArg;\n    const negativeValue = preset !== undefined ? preset : false;\n    return option.negate === (negativeValue === value);\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return {\n    shortFlag,\n    longFlag\n  };\n}\nexports.Option = Option;\nexports.splitOptionFlags = splitOptionFlags;\nexports.DualOptions = DualOptions;","map":{"version":3,"names":["InvalidArgumentError","require","Option","constructor","flags","description","required","includes","optional","variadic","test","mandatory","optionFlags","splitOptionFlags","short","shortFlag","long","longFlag","negate","startsWith","defaultValue","undefined","defaultValueDescription","presetArg","envVar","parseArg","hidden","argChoices","conflictsWith","implied","default","value","preset","arg","conflicts","names","concat","implies","impliedOptionValues","newImplied","Object","assign","env","name","argParser","fn","makeOptionMandatory","hideHelp","hide","_concatValue","previous","Array","isArray","choices","values","slice","join","replace","attributeName","camelcase","is","isBoolean","DualOptions","options","positiveOptions","Map","negativeOptions","dualOptions","Set","forEach","option","set","key","has","add","valueFromOption","optionKey","get","negativeValue","str","split","reduce","word","toUpperCase","flagParts","length","shift","exports"],"sources":["/Users/a1/new app/frontend/node_modules/auth/node_modules/commander/lib/option.js"],"sourcesContent":["const { InvalidArgumentError } = require('./error.js');\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n    this.implied = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {*} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {*} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {string | string[]} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   *\n   * @param {Object} impliedOptionValues\n   * @return {Option}\n   */\n  implies(impliedOptionValues) {\n    let newImplied = impliedOptionValues;\n    if (typeof impliedOptionValues === 'string') {\n      // string is not documented, but easy mistake and we can do what user probably intended.\n      newImplied = { [impliedOptionValues]: true };\n    }\n    this.implied = Object.assign(this.implied || {}, newImplied);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   *\n   * An environment variable is only used if when processed the current option value is\n   * undefined, or the source of the current value is 'default' or 'config' or 'env'.\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @api private\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.\n */\nclass DualOptions {\n  /**\n   * @param {Option[]} options\n   */\n  constructor(options) {\n    this.positiveOptions = new Map();\n    this.negativeOptions = new Map();\n    this.dualOptions = new Set();\n    options.forEach(option => {\n      if (option.negate) {\n        this.negativeOptions.set(option.attributeName(), option);\n      } else {\n        this.positiveOptions.set(option.attributeName(), option);\n      }\n    });\n    this.negativeOptions.forEach((value, key) => {\n      if (this.positiveOptions.has(key)) {\n        this.dualOptions.add(key);\n      }\n    });\n  }\n\n  /**\n   * Did the value come from the option, and not from possible matching dual option?\n   *\n   * @param {*} value\n   * @param {Option} option\n   * @returns {boolean}\n   */\n  valueFromOption(value, option) {\n    const optionKey = option.attributeName();\n    if (!this.dualOptions.has(optionKey)) return true;\n\n    // Use the value to deduce if (probably) came from the option.\n    const preset = this.negativeOptions.get(optionKey).presetArg;\n    const negativeValue = (preset !== undefined) ? preset : false;\n    return option.negate === (negativeValue === value);\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.splitOptionFlags = splitOptionFlags;\nexports.DualOptions = DualOptions;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}