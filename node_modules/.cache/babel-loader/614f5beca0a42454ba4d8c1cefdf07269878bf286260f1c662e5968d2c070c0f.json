{"ast":null,"code":"const {\n  humanReadableArgName\n} = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n    this.showGlobalOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName).helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Compare options for sort.\n   *\n   * @param {Option} a\n   * @param {Option} b\n   * @returns number\n   */\n  compareOptions(a, b) {\n    const getSortKey = option => {\n      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.\n      return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n    };\n    return getSortKey(a).localeCompare(getSortKey(b));\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter(option => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      visibleOptions.sort(this.compareOptions);\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the visible global options. (Not including help.)\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleGlobalOptions(cmd) {\n    if (!this.showGlobalOptions) return [];\n    const globalOptions = [];\n    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {\n      const visibleOptions = ancestorCmd.options.filter(option => !option.hidden);\n      globalOptions.push(...visibleOptions);\n    }\n    if (this.sortOptions) {\n      globalOptions.sort(this.compareOptions);\n    }\n    return globalOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd.registeredArguments.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd.registeredArguments.find(argument => argument.description)) {\n      return cmd.registeredArguments;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd.registeredArguments.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + (\n    // simplistic check for non-help option\n    args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest global option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestGlobalOptionTermLength(cmd, helper) {\n    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let ancestorCmdNames = '';\n    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {\n      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;\n    }\n    return ancestorCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the subcommand summary to show in the list of subcommands.\n   * (Fallback to description for backwards compatibility.)\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.summary() || cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n    if (option.argChoices) {\n      extraInfo.push(\n      // use stringify to match the display of the default value\n      `choices: ${option.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === 'boolean';\n      if (showDefault) {\n        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n      // use stringify to match the display of the default value\n      `choices: ${argument.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    }\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map(argument => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map(option => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n    if (this.showGlobalOptions) {\n      const globalOptionList = helper.visibleGlobalOptions(cmd).map(option => {\n        return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n      });\n      if (globalOptionList.length > 0) {\n        output = output.concat(['Global Options:', formatList(globalOptionList), '']);\n      }\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map(cmd => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestGlobalOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Full \\s characters, minus the linefeeds.\n    const indents = ' \\\\f\\\\t\\\\v\\u00a0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff';\n    // Detect manually wrapped and indented strings by searching for line break followed by spaces.\n    const manualIndent = new RegExp(`[\\\\n][${indents}]+`);\n    if (str.match(manualIndent)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n    const leadingStr = str.slice(0, indent);\n    const columnText = str.slice(indent).replace('\\r\\n', '\\n');\n    const indentString = ' '.repeat(indent);\n    const zeroWidthSpace = '\\u200B';\n    const breaks = `\\\\s${zeroWidthSpace}`;\n    // Match line end (so empty lines don't collapse),\n    // or as much text as will fit in column, or excess text up to first break.\n    const regex = new RegExp(`\\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line === '\\n') return ''; // preserve empty lines\n      return (i > 0 ? indentString : '') + line.trimEnd();\n    }).join('\\n');\n  }\n}\nexports.Help = Help;","map":{"version":3,"names":["humanReadableArgName","require","Help","constructor","helpWidth","undefined","sortSubcommands","sortOptions","showGlobalOptions","visibleCommands","cmd","commands","filter","_hidden","_hasImplicitHelpCommand","helpName","helpArgs","_helpCommandnameAndArgs","match","helpCommand","createCommand","helpOption","description","_helpCommandDescription","arguments","push","sort","a","b","name","localeCompare","compareOptions","getSortKey","option","short","replace","long","visibleOptions","options","hidden","showShortHelpFlag","_hasHelpOption","_helpShortFlag","_findOption","showLongHelpFlag","_helpLongFlag","createOption","_helpDescription","_helpFlags","visibleGlobalOptions","globalOptions","ancestorCmd","parent","visibleArguments","_argsDescription","registeredArguments","forEach","argument","find","subcommandTerm","args","map","arg","join","_name","_aliases","length","optionTerm","flags","argumentTerm","longestSubcommandTermLength","helper","reduce","max","command","Math","longestOptionTermLength","longestGlobalOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","ancestorCmdNames","usage","commandDescription","subcommandDescription","summary","optionDescription","extraInfo","argChoices","choice","JSON","stringify","defaultValue","showDefault","required","optional","isBoolean","defaultValueDescription","presetArg","envVar","argumentDescription","extraDescripton","formatHelp","termWidth","padWidth","itemIndentWidth","itemSeparatorWidth","formatItem","term","fullText","padEnd","wrap","formatList","textArray","repeat","output","concat","argumentList","optionList","globalOptionList","commandList","str","width","indent","minColumnWidth","indents","manualIndent","RegExp","columnWidth","leadingStr","slice","columnText","indentString","zeroWidthSpace","breaks","regex","lines","line","i","trimEnd","exports"],"sources":["/Users/a1/new app/frontend/node_modules/auth/node_modules/commander/lib/help.js"],"sourcesContent":["const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n    this.showGlobalOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Compare options for sort.\n   *\n   * @param {Option} a\n   * @param {Option} b\n   * @returns number\n   */\n  compareOptions(a, b) {\n    const getSortKey = (option) => {\n      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.\n      return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n    };\n    return getSortKey(a).localeCompare(getSortKey(b));\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      visibleOptions.sort(this.compareOptions);\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the visible global options. (Not including help.)\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleGlobalOptions(cmd) {\n    if (!this.showGlobalOptions) return [];\n\n    const globalOptions = [];\n    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {\n      const visibleOptions = ancestorCmd.options.filter((option) => !option.hidden);\n      globalOptions.push(...visibleOptions);\n    }\n    if (this.sortOptions) {\n      globalOptions.sort(this.compareOptions);\n    }\n    return globalOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd.registeredArguments.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd.registeredArguments.find(argument => argument.description)) {\n      return cmd.registeredArguments;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd.registeredArguments.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest global option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestGlobalOptionTermLength(cmd, helper) {\n    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let ancestorCmdNames = '';\n    for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {\n      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;\n    }\n    return ancestorCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the subcommand summary to show in the list of subcommands.\n   * (Fallback to description for backwards compatibility.)\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.summary() || cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault = option.required || option.optional ||\n        (option.isBoolean() && typeof option.defaultValue === 'boolean');\n      if (showDefault) {\n        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    }\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([helper.wrap(commandDescription, helpWidth, 0), '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    if (this.showGlobalOptions) {\n      const globalOptionList = helper.visibleGlobalOptions(cmd).map((option) => {\n        return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n      });\n      if (globalOptionList.length > 0) {\n        output = output.concat(['Global Options:', formatList(globalOptionList), '']);\n      }\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestGlobalOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Full \\s characters, minus the linefeeds.\n    const indents = ' \\\\f\\\\t\\\\v\\u00a0\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff';\n    // Detect manually wrapped and indented strings by searching for line break followed by spaces.\n    const manualIndent = new RegExp(`[\\\\n][${indents}]+`);\n    if (str.match(manualIndent)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.slice(0, indent);\n    const columnText = str.slice(indent).replace('\\r\\n', '\\n');\n    const indentString = ' '.repeat(indent);\n    const zeroWidthSpace = '\\u200B';\n    const breaks = `\\\\s${zeroWidthSpace}`;\n    // Match line end (so empty lines don't collapse),\n    // or as much text as will fit in column, or excess text up to first break.\n    const regex = new RegExp(`\\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`, 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line === '\\n') return ''; // preserve empty lines\n      return ((i > 0) ? indentString : '') + line.trimEnd();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}